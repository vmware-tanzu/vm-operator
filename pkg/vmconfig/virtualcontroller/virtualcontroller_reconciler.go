// Â© Broadcom. All Rights Reserved.
// The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
// SPDX-License-Identifier: Apache-2.0

package virtualcontroller

import (
	"context"
	"errors"
	"slices"

	"github.com/vmware/govmomi/vim25"
	"github.com/vmware/govmomi/vim25/mo"
	vimtypes "github.com/vmware/govmomi/vim25/types"
	ctrlclient "sigs.k8s.io/controller-runtime/pkg/client"

	vmopv1 "github.com/vmware-tanzu/vm-operator/api/v1alpha5"
	pkglog "github.com/vmware-tanzu/vm-operator/pkg/log"
	"github.com/vmware-tanzu/vm-operator/pkg/vmconfig"
)

// Reconcile configures the VM's virtual controllers.
func Reconcile(
	ctx context.Context,
	k8sClient ctrlclient.Client,
	vimClient *vim25.Client,
	vm *vmopv1.VirtualMachine,
	moVM mo.VirtualMachine,
	configSpec *vimtypes.VirtualMachineConfigSpec) error {

	return New().Reconcile(ctx, k8sClient, vimClient, vm, moVM, configSpec)
}

type reconciler struct{}

var _ vmconfig.Reconciler = reconciler{}

func New() vmconfig.Reconciler {
	return reconciler{}
}

func (r reconciler) Name() string {
	return "virtualcontroller"
}

func (r reconciler) OnResult(
	_ context.Context,
	_ *vmopv1.VirtualMachine,
	_ mo.VirtualMachine,
	_ error) error {

	return nil
}

// Reconcile reconciles the virtual controllers.
// It compares the existing controllers with the desired controller spec,
// figures out the controllers to be added, edited, and removed.
func (r reconciler) Reconcile(
	ctx context.Context,
	k8sClient ctrlclient.Client,
	vimClient *vim25.Client,
	vm *vmopv1.VirtualMachine,
	moVM mo.VirtualMachine,
	configSpec *vimtypes.VirtualMachineConfigSpec) error {

	if ctx == nil {
		panic("context is nil")
	}
	if k8sClient == nil {
		panic("k8sClient is nil")
	}
	if vimClient == nil {
		panic("vimClient is nil")
	}
	if vm == nil {
		panic("vm is nil")
	}
	if configSpec == nil {
		panic("configSpec is nil")
	}

	if moVM.Config == nil {
		return nil
	}

	var (
		existingIDEControllerBusNumberDeviceMap  = map[int32]*vimtypes.VirtualIDEController{}
		existingNVMEControllerBusNumberDeviceMap = map[int32]*vimtypes.VirtualNVMEController{}
		existingSATAControllerBusNumberDeviceMap = map[int32]*vimtypes.VirtualAHCIController{}
		existingSCSIControllerBusNumberDeviceMap = map[int32]vimtypes.BaseVirtualSCSIController{}

		pciController *vimtypes.VirtualPCIController

		// A temporary key assigned to newly added controller. It will be
		// overwritten by server once it's assigned. Without it we can't create
		// multiple devices using same DeviceChange.
		newDeviceKey int32
	)

	// Collect all the existing controller device keys.
	for _, d := range moVM.Config.Hardware.Device {
		switch d := d.(type) {

		// IDE
		case *vimtypes.VirtualIDEController:
			existingIDEControllerBusNumberDeviceMap[d.BusNumber] = d

		// NVME
		case *vimtypes.VirtualNVMEController:
			existingNVMEControllerBusNumberDeviceMap[d.BusNumber] = d

		// SATA
		case *vimtypes.VirtualAHCIController:
			existingSATAControllerBusNumberDeviceMap[d.BusNumber] = d

		// SCSI
		case vimtypes.BaseVirtualSCSIController:
			existingSCSIControllerBusNumberDeviceMap[d.GetVirtualSCSIController().BusNumber] = d

		// PCI
		case *vimtypes.VirtualPCIController:
			pciController = d
		}
	}

	oldDeviceChangeCount := len(configSpec.DeviceChange)

	if pciController == nil {
		// This shouldn't happen since PCI Controller will always be created
		// by default and can't be removed.
		return errors.New("PCI Controller not presented")
	}

	initDeviceKey(&newDeviceKey, configSpec.DeviceChange)

	reconcileIDEControllers(
		ctx,
		configSpec,
		&newDeviceKey,
		pciController,
		vm.Spec.Hardware,
		existingIDEControllerBusNumberDeviceMap,
	)

	reconcileNVMEControllers(
		ctx,
		configSpec,
		&newDeviceKey,
		pciController,
		vm.Spec.Hardware,
		existingNVMEControllerBusNumberDeviceMap,
	)

	reconcileSATAControllers(
		ctx,
		configSpec,
		&newDeviceKey,
		pciController,
		vm.Spec.Hardware,
		existingSATAControllerBusNumberDeviceMap)

	reconcileSCSIControllers(
		ctx,
		configSpec,
		&newDeviceKey,
		pciController,
		vm.Spec.Hardware,
		existingSCSIControllerBusNumberDeviceMap)

	if len(configSpec.DeviceChange) > oldDeviceChangeCount {
		pkglog.FromContextOrDefault(ctx).V(4).Info(
			"Device change generated by virtualcontroller",
			"DeviceChange", configSpec.DeviceChange[oldDeviceChangeCount:])
	}

	// Only allow add/delete ops when VM is poweredOn, not edit.
	if slices.ContainsFunc(
		configSpec.DeviceChange[oldDeviceChangeCount:],
		func(bdc vimtypes.BaseVirtualDeviceConfigSpec) bool {
			dc := bdc.GetVirtualDeviceConfigSpec()
			return dc != nil &&
				dc.Operation == vimtypes.VirtualDeviceConfigSpecOperationEdit
		},
	) {
		if moVM.Runtime.PowerState != vimtypes.VirtualMachinePowerStatePoweredOff {
			pkglog.FromContextOrDefault(ctx).Info("hot-update virtual controllers when VM is not powered off is not allowed, skip updating. " +
				"Please check VirtualMachineHardwareControllersVerified condition for details")
			// Clear any new updates from DeviceChange.
			configSpec.DeviceChange = slices.Delete(
				configSpec.DeviceChange,
				oldDeviceChangeCount,
				len(configSpec.DeviceChange),
			)

			return nil
		}
	}

	return nil
}

// initDeviceKey initialize newDeviceKey with lowest key value among all devices
// in []deviceChange array.
func initDeviceKey(newDeviceKey *int32, deviceChange []vimtypes.BaseVirtualDeviceConfigSpec) {
	for i := range deviceChange {
		var (
			bdc vimtypes.BaseVirtualDeviceConfigSpec
			bvd vimtypes.BaseVirtualDevice
			dc  *vimtypes.VirtualDeviceConfigSpec
			d   *vimtypes.VirtualDevice
		)

		if bdc = deviceChange[i]; bdc == nil {
			continue
		}

		if dc = bdc.GetVirtualDeviceConfigSpec(); dc == nil {
			continue
		}

		if dc.Operation == vimtypes.VirtualDeviceConfigSpecOperationRemove {
			// Do not consider devices being removed.
			continue
		}

		bvd = dc.Device
		if bvd == nil {
			continue
		}

		if d = bvd.GetVirtualDevice(); d == nil {
			continue
		}

		// Keep track of the smallest device key used. Please note, because
		// device keys in a ConfigSpec are negative numbers, -200 going to be
		// smaller than -1.
		if d.Key < *newDeviceKey {
			*newDeviceKey = d.Key
		}
	}
}

// reconcileIDEControllers reconciles the IDE controllers.
// It compares the existing controllers with the desired controller spec,
// figures out the controllers to be added, edited, and removed.
func reconcileIDEControllers(
	ctx context.Context,
	configSpec *vimtypes.VirtualMachineConfigSpec,
	newDeviceKey *int32,
	pciController *vimtypes.VirtualPCIController,
	hardwareSpec *vmopv1.VirtualMachineHardwareSpec,
	existingIDEControllerBusNumberDeviceMap map[int32]*vimtypes.VirtualIDEController) {

	var (
		desiredIDEControllerBusNumberSpecMap = map[int32]vmopv1.IDEControllerSpec{}
	)

	if hardwareSpec != nil && hardwareSpec.IDEControllers != nil {
		for _, controller := range hardwareSpec.IDEControllers {
			desiredIDEControllerBusNumberSpecMap[controller.BusNumber] = controller
		}
	}

	// Find the bus numbers to be added/edited/removed.
	// We only expose bus number so we don't support editing IDEController
	toAdd, _, toRemove :=
		diffIDEControllerByBusNumber(
			ctx,
			existingIDEControllerBusNumberDeviceMap,
			desiredIDEControllerBusNumberSpecMap,
		)

	for _, dev := range toRemove {
		addDeviceChangeOp(configSpec,
			dev,
			vimtypes.VirtualDeviceConfigSpecOperationRemove)
	}

	for _, spec := range toAdd {
		addDeviceChangeOp(configSpec,
			newIDEController(spec, pciController, newDeviceKey),
			vimtypes.VirtualDeviceConfigSpecOperationAdd)
	}
}

// reconcileNVMEControllers reconciles the NVME controllers.
// It compares the existing controllers with the desired controller spec,
// figures out the controllers to be added, edited, and removed.
func reconcileNVMEControllers(
	ctx context.Context,
	configSpec *vimtypes.VirtualMachineConfigSpec,
	newDeviceKey *int32,
	pciController *vimtypes.VirtualPCIController,
	hardwareSpec *vmopv1.VirtualMachineHardwareSpec,
	existingNVMEControllerBusNumberDeviceMap map[int32]*vimtypes.VirtualNVMEController) {

	var (
		desiredNVMEControllerBusNumberSpecMap = map[int32]vmopv1.NVMEControllerSpec{}
	)

	if hardwareSpec != nil && hardwareSpec.NVMEControllers != nil {
		for _, controller := range hardwareSpec.NVMEControllers {
			if err := validateNVMEController(controller); err != nil {
				pkglog.FromContextOrDefault(ctx).Error(err,
					"failed to validate NVMEController, skip it")
				continue
			}
			desiredNVMEControllerBusNumberSpecMap[controller.BusNumber] = controller
		}
	}

	// Find the bus numbers to be added/edited/removed.
	toAdd, toEdit, toRemove :=
		diffNVMEControllerByBusNumber(
			ctx,
			existingNVMEControllerBusNumberDeviceMap,
			desiredNVMEControllerBusNumberSpecMap,
		)

	for _, dev := range toRemove {
		addDeviceChangeOp(configSpec,
			dev,
			vimtypes.VirtualDeviceConfigSpecOperationRemove)
	}

	for _, spec := range toAdd {
		addDeviceChangeOp(configSpec,
			newNVMEController(ctx, spec, pciController, newDeviceKey),
			vimtypes.VirtualDeviceConfigSpecOperationAdd)
	}

	for _, dev := range toEdit {
		addDeviceChangeOp(configSpec,
			dev,
			vimtypes.VirtualDeviceConfigSpecOperationEdit)
	}
}

// reconcileSATAControllers reconciles the SATA controllers.
// It compares the existing controllers with the desired controller spec,
// figures out the controllers to be added, edited, and removed.
func reconcileSATAControllers(
	ctx context.Context,
	configSpec *vimtypes.VirtualMachineConfigSpec,
	newDeviceKey *int32,
	pciController *vimtypes.VirtualPCIController,
	hardwareSpec *vmopv1.VirtualMachineHardwareSpec,
	existingSATAControllerBusNumberDeviceMap map[int32]*vimtypes.VirtualAHCIController) {

	var (
		desiredSATAControllerBusNumberSpecMap = map[int32]vmopv1.SATAControllerSpec{}
	)

	if hardwareSpec != nil && hardwareSpec.SATAControllers != nil {
		for _, controller := range hardwareSpec.SATAControllers {
			desiredSATAControllerBusNumberSpecMap[controller.BusNumber] = controller
		}
	}

	// Find the bus numbers to be removed and to be added.
	toAdd, toEdit, toRemove :=
		diffSATAControllerByBusNumber(
			ctx,
			existingSATAControllerBusNumberDeviceMap,
			desiredSATAControllerBusNumberSpecMap,
		)

	for _, dev := range toRemove {
		addDeviceChangeOp(configSpec,
			dev,
			vimtypes.VirtualDeviceConfigSpecOperationRemove)
	}

	for _, spec := range toAdd {
		addDeviceChangeOp(configSpec,
			newSATAController(spec, pciController, newDeviceKey),
			vimtypes.VirtualDeviceConfigSpecOperationAdd)
	}

	for _, dev := range toEdit {
		addDeviceChangeOp(configSpec,
			dev,
			vimtypes.VirtualDeviceConfigSpecOperationEdit)
	}
}

// reconcileSCSIControllers reconciles the SCSI controllers.
// It compares the existing controllers with the desired controller spec,
// figures out the controllers to be added, edited, and removed.
func reconcileSCSIControllers(
	ctx context.Context,
	configSpec *vimtypes.VirtualMachineConfigSpec,
	newDeviceKey *int32,
	pciController *vimtypes.VirtualPCIController,
	hardwareSpec *vmopv1.VirtualMachineHardwareSpec,
	existingSCSIControllerBusNumberDeviceMap map[int32]vimtypes.BaseVirtualSCSIController) {

	var (
		desiredSCSIControllerBusNumberSpecMap = map[int32]vmopv1.SCSIControllerSpec{}
	)

	if hardwareSpec != nil && hardwareSpec.SCSIControllers != nil {
		for _, controller := range hardwareSpec.SCSIControllers {
			desiredSCSIControllerBusNumberSpecMap[controller.BusNumber] = controller
		}
	}

	// Find the bus numbers to be removed and to be added.
	toAdd, toEdit, toRemove :=
		diffSCSIControllerByBusNumber(
			ctx,
			existingSCSIControllerBusNumberDeviceMap,
			desiredSCSIControllerBusNumberSpecMap,
		)

	for _, dev := range toRemove {
		addDeviceChangeOp(configSpec,
			dev.(vimtypes.BaseVirtualDevice),
			vimtypes.VirtualDeviceConfigSpecOperationRemove)
	}

	for _, spec := range toAdd {
		addDeviceChangeOp(configSpec,
			newSCSIController(ctx, spec, pciController, newDeviceKey).(vimtypes.BaseVirtualDevice),
			vimtypes.VirtualDeviceConfigSpecOperationAdd)
	}

	for _, dev := range toEdit {
		addDeviceChangeOp(configSpec,
			dev.(vimtypes.BaseVirtualDevice),
			vimtypes.VirtualDeviceConfigSpecOperationEdit)
	}
}
